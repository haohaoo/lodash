**将数组拆分成多个 size 长度的块，并组成一个新数组。 如果数组无法被分割成全部等长的块，那么最后剩余的元素将组成一个块。**

* chunk
  * slice

### STYLE
获取 Array.length 的校验

`const length = array == null ? 0 : array.length`

将 ++ += 等运算包含到运算中

`result[resIndex] = slice(array, index, (index + size))`

`resIndex++`

`index += size`

=>

`result[resIndex++] = slice(array, index, (index += size))`

用 while 代替 for

### THINK
1. 传入参数无效的话，返回该函数应返回数据类型的空值

### POINT
#### 位运算

`>>>` 无符号右移位运算符

右移表达式的位，不保留符号

`result = expression1 >>> expression2`

运算符将 expression1 的位右移 expression2 中指定的位数。  用零填充右移后左边空出的位。  右移的位被丢弃。

`var temp`

`temp = -14 >>> 2`

变量 temp 具有初始值 -14（二进制补码 11111111 11111111 11111111 11110010）

其右移两位后，值等于 1073741820（即二进制的 00111111 11111111 11111111 11111100）

#### 原码 反码 补码
原码：将最高位作为符号位(0表示正，1表示负)，其它数字位代表数值本身的绝对值的数字表示方式

反码：如果是正数，则表示方法和原码一样；如果是负数，符号位不变，其余各位取反，则得到这个数字的反码表示形式。

补码：计算机表示数据的一般方式，其规则为：如果是整数，则表示方法和原码一样；如果是负数，则将数字的反码加上1(相当于将原码数值位取反然后在最低位加1)。

js 中的整型在内存中都是一个 64 位双精度浮点型，但是 js 进行位运算时，会将操作数转成带符号位的 32 位比特序列（0，1），也就是补码。运算结束后，再按照 64 位存储。这样就会丢失掉32位的精度。

js 中无符号右移时，不管正数、负数都会首先将符号位替换成 0，然后再进行移位。也就是说，该运算符永远返回正整数。
